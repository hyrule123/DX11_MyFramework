#include "pch.h"
#include "CGraphicsShader.h"

#include "CPathMgr.h"
#include "CDevice.h"

#include "jsoncpp.h"



namespace SHADER_EXTENSION
{
	constexpr const wchar_t* CSO = L".CSO";
	constexpr const wchar_t* FX = L".FX";
}


CGraphicsShader::CGraphicsShader()
	: CShader(eRES_TYPE::GRAPHICS_SHADER)
	, m_eTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST)
	, m_eRSType(define_Shader::eRASTERIZER_TYPE::CULL_BACK)
	, m_eDSType(define_Shader::eDEPTH_STENCIL_TYPE::LESS)
	, m_eBSType(define_Shader::eBLEND_STATE_TYPE::DEFAULT)
	, m_eShaderDomain(define_Shader::eSHADER_DOMAIN::_UNDEFINED)
	, m_arrShaderCode{}
	, m_bUseInstancing()
{
}

CGraphicsShader::~CGraphicsShader()
{
}


bool CGraphicsShader::SaveJson(Json::Value* _jsonVal)
{
	if (false == CShader::SaveJson(_jsonVal))
		return false;

	Json::Value& jVal = *_jsonVal;

	string comment = "//Enumeration Values are at define.h of Engine project";
	jVal.setComment(comment, Json::CommentPlacement::commentAfter);

	//순회를 돌면서 비트마스크를 만들어준뒤 json 파일에 저장한다.
	int flagPipeline = 0;
	for (int i = 0; i < (int)define_Shader::eSHADER_TYPE::END; ++i)
	{
		bool bExist = false;

		switch ((define_Shader::eSHADER_TYPE)i)
		{
		case define_Shader::eSHADER_TYPE::__VERTEX:
			if (nullptr != m_VS.Get())
				bExist = true;
			break;
		case define_Shader::eSHADER_TYPE::__HULL:
			if(nullptr != m_HS.Get())
				bExist = true;
			break;
		case define_Shader::eSHADER_TYPE::__DOMAIN:
			if (nullptr != m_DS.Get())
				bExist = true;
			break;
		case define_Shader::eSHADER_TYPE::__GEOMETRY:
			if (nullptr != m_GS.Get())
				bExist = true;
			break;
		case define_Shader::eSHADER_TYPE::__PIXEL:
			if (nullptr != m_PS.Get())
				bExist = true;
			break;

		default:
			break;
		}

		if (true == bExist)
			flagPipeline |= 1 << i;
	}

	using namespace RES_INFO::SHADER;

	jVal[GRAPHICS::JSON_KEY::D3D_PRIMITIVE_TOPOLOGY] = (int)m_eTopology;

	jVal[GRAPHICS::JSON_KEY::eRASTERIZER_TYPE] = (int)m_eRSType;
	jVal[GRAPHICS::JSON_KEY::eDEPTH_STENCIL_TYPE] = (int)m_eDSType;
	jVal[GRAPHICS::JSON_KEY::eBLEND_STATE_TYPE] = (int)m_eBSType;
	jVal[GRAPHICS::JSON_KEY::eSHADER_DOMAIN] = (int)m_eShaderDomain;
	jVal[GRAPHICS::JSON_KEY::m_bUseInstancing] = m_bUseInstancing;

	//쉐이더의 이름을 저장(없어도 저장)
	for (int i = 0; i < (int)define_Shader::eSHADER_TYPE::END; ++i)
	{
		jVal[GRAPHICS::JSON_KEY::arr_strKey_PipeLine[i]] = m_arrShaderCode[i].strKey;
	}

	return true;
}

bool CGraphicsShader::LoadJson(Json::Value* _jsonVal)
{
	if (false == CShader::LoadJson(_jsonVal))
		return false;

	const Json::Value& jVal = *_jsonVal;

#define CHECK_LOAD_ERROR(_strKey) \
if (false == jVal.isMember(_strKey))\
	throw(std::runtime_error(_strKey + string(" Load Failed!!")))

	try
	{
		{
			string strKey = RES_INFO::SHADER::GRAPHICS::JSON_KEY::eBLEND_STATE_TYPE;
			CHECK_LOAD_ERROR(strKey);
			m_eBSType = (define_Shader::eBLEND_STATE_TYPE)jVal[strKey].asInt();
		}

		{
			string strKey = RES_INFO::SHADER::GRAPHICS::JSON_KEY::eDEPTH_STENCIL_TYPE;
			CHECK_LOAD_ERROR(strKey);
			m_eDSType = (define_Shader::eDEPTH_STENCIL_TYPE)jVal[strKey].asInt();
		}

		{
			string strKey = string(RES_INFO::SHADER::GRAPHICS::JSON_KEY::eRASTERIZER_TYPE);
			CHECK_LOAD_ERROR(strKey);
			m_eRSType = (define_Shader::eRASTERIZER_TYPE)jVal[strKey].asInt();
		}

		{
			string strKey = string(RES_INFO::SHADER::GRAPHICS::JSON_KEY::D3D_PRIMITIVE_TOPOLOGY);
			CHECK_LOAD_ERROR(strKey);
			m_eTopology = (D3D11_PRIMITIVE_TOPOLOGY)jVal[strKey].asInt();
		}

		{
			string strKey = string(RES_INFO::SHADER::GRAPHICS::JSON_KEY::eSHADER_DOMAIN);
			CHECK_LOAD_ERROR(strKey);
			m_eShaderDomain = (define_Shader::eSHADER_DOMAIN)jVal[strKey].asInt();
		}


		if (define_Shader::eSHADER_DOMAIN::_UNDEFINED == m_eShaderDomain)
		{
			string errorMessage = "The shader domain value of ";
			errorMessage += GetName();
			errorMessage += " is Not set. May cause error.";
			DEBUG_BREAK;
			throw(std::runtime_error(errorMessage));
		}

		{
			string strKey = RES_INFO::SHADER::GRAPHICS::JSON_KEY::m_bUseInstancing;
			CHECK_LOAD_ERROR(strKey);
			m_bUseInstancing = jVal[strKey].asBool();
		}

		//자동 생성된 코드인지 여부 확인
		bool _bIsAutoGenerated = false;
		{
			string strKey = RES_INFO::SHADER::GRAPHICS::JSON_KEY::_bIsAutoGenerated;
			CHECK_LOAD_ERROR(strKey);
			_bIsAutoGenerated = jVal[strKey].asBool();
		}


		for (int i = 0; i < (int)define_Shader::eSHADER_TYPE::END; ++i)
		{
			const string strKey = RES_INFO::SHADER::GRAPHICS::JSON_KEY::arr_strKey_PipeLine[i];
			if (false == jVal.isMember(strKey))
			{
				assert(false);
				throw(std::runtime_error(string("Failed To get data of ") + strKey));
			}

			const string sFileName = jVal[strKey].asString();
			if (sFileName.empty())
			{
				//버텍스 쉐이더가 없을 경우에는 에러 발생
				if ((int)define_Shader::eSHADER_TYPE::__VERTEX == i)
				{
					string errmsg = "Vertex shader must exist but it is not.";
					errmsg += "\nPipeline Name : ";
					errmsg += GetKey();
					throw(std::runtime_error(errmsg));
				}
				else
					continue;
			}
				
			//CSO 파일이 있는 폴더에 접근
			std::filesystem::path shaderPath = 
				CPathMgr::GetInst()->GetPathAbs_Content() / DIRECTORY_NAME::SHADER_CSO / sFileName;

			//위에서 만든 파일명을 토대로 디스크에서 파일을 열어준다.
			std::ios_base::openmode openFlag = std::ios_base::ate | std::ios_base::binary; std::ios_base::in;
			std::ifstream sFile(shaderPath, openFlag);

			
			if (false == sFile.is_open())
				throw(std::runtime_error(string("Failed to open File.\n") + shaderPath.string()));

			//파일이 열리면 지역변수 Blob을 만들어서 데이터를 옮긴다.
			tShaderCode sCode = {};
			sCode.strKey = sFileName;

			//Blob 내부에 공간을 할당.
			HRESULT hr = D3DCreateBlob(sFile.tellg(), sCode.blob.GetAddressOf());
			if (FAILED(hr))
			{
				throw(std::runtime_error(string("Shader Blob Creation Failed.\nError Code: ") + std::to_string(hr)));
			}

			//커서를 처음으로 돌린 후 파일을 읽어준다.
			sFile.seekg(0, std::ios_base::beg);
			sFile.read((char*)sCode.blob->GetBufferPointer(), sCode.blob->GetBufferSize());
			sFile.close();

			//읽어온 바이트 코드로부터 쉐이더를 로딩해준다.
			//실패시 동적할당 해제하고 오류 발생
			hr = CreateShader(sCode, (define_Shader::eSHADER_TYPE)i);
			if (FAILED(hr))
			{
				throw(std::runtime_error(string("Shader Blob Creation Failed.\nError Code: ") + std::to_string(hr)));
			}

		}


	}
	catch (const std::runtime_error& _err)
	{
		ERROR_MESSAGE(_err.what());
		return false;
	}


	return true;
}


HRESULT CGraphicsShader::CreateDefaultInputLayout()
{
	// InputLayout 생성
	constexpr UINT uNumDesc = 2u;
	D3D11_INPUT_ELEMENT_DESC LayoutDesc[uNumDesc] = {};

	LayoutDesc[0].SemanticName = "POSITION";
	LayoutDesc[0].SemanticIndex = 0;
	LayoutDesc[0].AlignedByteOffset = 0;
	LayoutDesc[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
	LayoutDesc[0].InputSlot = 0;
	LayoutDesc[0].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
	LayoutDesc[0].InstanceDataStepRate = 0;
	

	//LayoutDesc[1].SemanticName = "COLOR";
	//LayoutDesc[1].SemanticIndex = 0;

	////이전 시멘틱에서 얼마나 떨어졌는지 여부를 저장. 0번 인덱스는 R32B32G32(4+4+4 = 12) 이므로 오프셋을 12로 잡아준다.
	//LayoutDesc[1].AlignedByteOffset = 12;					
	//LayoutDesc[1].Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
	//LayoutDesc[1].InputSlot = 0;
	//LayoutDesc[1].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
	//LayoutDesc[1].InstanceDataStepRate = 0;

	LayoutDesc[1].SemanticName = "TEXCOORD";
	LayoutDesc[1].SemanticIndex = 0;

	//0번 인덱스1: 12 , 1번 인덱스 : R32B32G32A32(4 * 4 = 16) -> 12 + 16 = 28
	LayoutDesc[1].AlignedByteOffset = 12;
	LayoutDesc[1].Format = DXGI_FORMAT_R32G32_FLOAT;
	LayoutDesc[1].InputSlot = 0;
	LayoutDesc[1].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
	LayoutDesc[1].InstanceDataStepRate = 0;
	
	const tShaderCode& shaderCode = m_arrShaderCode[(int)define_Shader::eSHADER_TYPE::__VERTEX];

	//Vertex Buffer Blob을 참조해서 입력 레이아웃을 생성한다.
	const ComPtr<ID3DBlob>& VSData = shaderCode.blob;
	return DEVICE->CreateInputLayout(LayoutDesc, uNumDesc, VSData->GetBufferPointer(), VSData->GetBufferSize(), m_InputLayout.ReleaseAndGetAddressOf());

	return E_FAIL;
}



HRESULT CGraphicsShader::CreateShaderFromHeader(const unsigned char* _pByteCode, size_t _ByteCodeSize, define_Shader::eSHADER_TYPE _eShaderType)
{
	//헤더 형태로 만드는 쉐이더는 무조건 엔진 내부 기본 리소스라고 가정한다.
	SetEngineDefaultRes(true);

	tShaderCode& code = m_arrShaderCode[(int)_eShaderType];

	HRESULT hr = D3DCreateBlob(_ByteCodeSize, code.blob.ReleaseAndGetAddressOf());
	if (FAILED(hr))
	{
		DEBUG_BREAK;
		return hr;
	}

	unsigned char* pCode = reinterpret_cast<unsigned char*>(code.blob->GetBufferPointer());
	//할당된 메모리 사이즈는 무조건 같아야 함
	size_t DestSize = code.blob->GetBufferSize();
	assert(_ByteCodeSize == DestSize);

	//데이터 복사
	memcpy_s(pCode, DestSize, _pByteCode, _ByteCodeSize);

	return CreateShaderPrivate(pCode, DestSize, _eShaderType);
}


HRESULT CGraphicsShader::CreateShaderPrivate(const void* _pByteCode, size_t _ByteCodeSize, define_Shader::eSHADER_TYPE _ShaderType)
{
	assert(_pByteCode && _ByteCodeSize);

	int i = (int)_ShaderType;

	switch (_ShaderType)
	{
	case define_Shader::eSHADER_TYPE::__VERTEX:
	{
		HRESULT hr = DEVICE->CreateVertexShader(_pByteCode, _ByteCodeSize, nullptr, m_VS.ReleaseAndGetAddressOf());

		if (SUCCEEDED(hr))
			CreateDefaultInputLayout();

		return hr;

		break;
	}

	case define_Shader::eSHADER_TYPE::__HULL:
		return DEVICE->CreateHullShader(_pByteCode, _ByteCodeSize, nullptr, m_HS.ReleaseAndGetAddressOf());
		break;

	case define_Shader::eSHADER_TYPE::__DOMAIN:
		return DEVICE->CreateDomainShader(_pByteCode, _ByteCodeSize, nullptr, m_DS.ReleaseAndGetAddressOf());
		break;

	case define_Shader::eSHADER_TYPE::__GEOMETRY:
		return DEVICE->CreateGeometryShader(_pByteCode, _ByteCodeSize, nullptr, m_GS.ReleaseAndGetAddressOf());
		break;

	case define_Shader::eSHADER_TYPE::__PIXEL:
		return DEVICE->CreatePixelShader(_pByteCode, _ByteCodeSize, nullptr, m_PS.ReleaseAndGetAddressOf());
		break;

	default:
		return E_FAIL;
	}

	return E_FAIL;
}

HRESULT CGraphicsShader::CreateShader(const std::filesystem::path& _FileName, const string_view _strFuncName, define_Shader::eSHADER_TYPE _ShaderType)
{
	if (GetKey().empty())
		SetKey(_FileName.string());

	// 1. Shader 파일 경로 받아옴
	std::filesystem::path shaderPath = GETRESPATH;
	shaderPath /= _FileName;

	//2. 쉐이더 타입에 따른 다른 파라미터용 변수를 할당
	char ShaderNameVersion[32u] = {};
	strcpy_s(ShaderNameVersion, 32u, SHADER_NAME_VERSION::GS[(int)_ShaderType]);

	ComPtr<ID3DBlob> pBlob = m_arrShaderCode[(int)_ShaderType].blob;

	// Shader Compile
	HRESULT hr = D3DCompileFromFile(shaderPath.wstring().c_str(), nullptr, D3D_COMPILE_STANDARD_FILE_INCLUDE
		, string(_strFuncName).c_str(), ShaderNameVersion, 0, 0, pBlob.ReleaseAndGetAddressOf(), m_ErrBlob.ReleaseAndGetAddressOf());

	if(FAILED(hr))
	{
		MessageBoxA(nullptr, (const char*)m_ErrBlob->GetBufferPointer()
			, "Vertex Shader Compile Failed!!", MB_OK);
		assert(SUCCEEDED(hr));
		return hr;
	}

	return CreateShaderPrivate(pBlob->GetBufferPointer(), pBlob->GetBufferSize(), _ShaderType);
}


void CGraphicsShader::BindData()
{
	ID3D11DeviceContext* pContext = CONTEXT;

	//Set Input Layout
	pContext->IASetInputLayout(m_InputLayout.Get());
	pContext->IASetPrimitiveTopology(m_eTopology);


	pContext->VSSetShader(m_VS.Get(), nullptr, 0);
	pContext->HSSetShader(m_HS.Get(), nullptr, 0);
	pContext->DSSetShader(m_DS.Get(), nullptr, 0);
	pContext->GSSetShader(m_GS.Get(), nullptr, 0);
	pContext->PSSetShader(m_PS.Get(), nullptr, 0);


	//Set Rasterizer
	pContext->RSSetState(CDevice::GetInst()->GetRSState(m_eRSType));

	//Set Output Merger(Depth Stencil, Blend)
	pContext->OMSetDepthStencilState(CDevice::GetInst()->GetDSState(m_eDSType), 0);
	pContext->OMSetBlendState(CDevice::GetInst()->GetBSState(m_eBSType), Vec4(0.f, 0.f, 0.f, 0.f), UINT_MAX);
}




