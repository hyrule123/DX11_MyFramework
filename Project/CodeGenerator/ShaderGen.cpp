#include "pch.h"

#include "CodeGenFunc.h"

#include "MacroFunc.h"



#include <UtilLib_DLL/json/json.h>
#include <Engine/define.h>
#include <d3dcommon.h>

#ifdef _DEBUG
#pragma comment(lib, "Engine/Engine_Debug")
#else
#pragma comment(lib, "Engine/Engine_Release")
#endif

#include <Engine/CComputeShader.h>
#include <Engine/CGraphicsShader.h>

//순수가상함수 풀고 저장기능만 사용하기 위한 더미 클래스
class CDummyCompute
	: public CComputeShader
{
public:
	CDummyCompute() {};
	virtual ~CDummyCompute() {};

	virtual bool BindDataCS() { return true; };
	virtual void UnBindCS() {};
};


struct tShaderSetting
{
	string FileName[(int)eSHADER_TYPE::END];
};

void InitShaderSettingGraphics(Json::Value& _jVal, const pair<string, tShaderSetting>& _mapPair);
void InitShaderSettingCompute(Json::Value& _jVal, const filesystem::path& _filePath);

void CreateShaderCode()
{
	//first(Key) = json파일의 이름
	map<string, tShaderSetting> mapShaderInfo;

	filesystem::path ContentDir(PresetPath::Content);
	filesystem::path GSShaderDir = ContentDir / RES_INFO::SHADER::GRAPHICS::DirName;

	//Content/Shader/Graphics 폴더 안의 파일을 순회돌아준다.
	filesystem::directory_iterator dirIter;
	try
	{
		dirIter = filesystem::directory_iterator(GSShaderDir);


		filesystem::directory_iterator dirIterEnd = std::filesystem::end(dirIter);
		for (dirIter; dirIter != dirIterEnd; ++dirIter)
		{
			const filesystem::directory_entry& file = *dirIter;

			if (false == file.is_directory())
			{
				//파일명을 받아온다.
				filesystem::path SFileName = file.path().lexically_relative(GSShaderDir);

				//확장자가 .cso로 끝나는지 확인한다. 확장자가 cso가 아닐 경우 쉐이더가 아니므로 continue;
				if (SFileName.extension() != RES_INFO::SHADER::Ext_ShaderCode)
					continue;

				//확장자 제거
				string SFileNameBase = SFileName.replace_extension("").string();

				//이름을 통해서 어떤 파이프라인인지를 유추한다.
				for (int i = 0; i < (int)eSHADER_TYPE::END; ++i)
				{
					size_t strPos = SFileNameBase.find(RES_INFO::SHADER::GRAPHICS::arrPrefix[i]);
					if (string::npos != strPos)
					{
						//Prefix를 제거
						//이러면 키값으로 사용할 문자열이 남는다.
						SFileNameBase.erase(0, strPos + strlen(RES_INFO::SHADER::GRAPHICS::arrPrefix[i]));

						//자신의 쉐이더 파이프라인에 이름을 삽입
						mapShaderInfo[SFileNameBase].FileName[i] = SFileName.string();

						break;
					}
				}
			}
		}

	}
	catch (const filesystem::filesystem_error& error)
	{
		MessageBoxA(nullptr, "Unable to Iterate Directory.", nullptr, MB_OK);
		throw(error);
	}
	//생성된 HLSL 파일 순회 끝
	vector<string> vecStrModified;


	bool bNewShaderDetected = false;
	bool bModifyDetected = false;
	//map을 순회돌아주면서 파일을 열어본다.
	//파일명은 'Key값'이다.
	Json::Value JsonInfo;
	for (const auto& mapIter : mapShaderInfo)
	{
		//JSON 경로 생성
		filesystem::path JsonPath = GSShaderDir;

		bool bAnythingChanged = false;

		JsonPath /= mapIter.first;
		JsonPath.replace_extension(RES_INFO::SHADER::Ext_ShaderSetting);

		ifstream fpJsonIn(JsonPath);
		//파일이 열렸으면 데이터를 읽어온다.
		if (true == fpJsonIn.is_open())
		{
			fpJsonIn >> JsonInfo;

			fpJsonIn.close();
		}
		//파일이 없을 경우 JsonValue를 포맷에 맞게 초기화시킨다.
		//초기화될 때 이름은 자동으로 들어감.
		else
		{
			InitShaderSettingGraphics(JsonInfo, mapIter);
			bAnythingChanged = true;
			bNewShaderDetected = true;
			vecStrModified.push_back(mapIter.first);
		}


		//"""""정규화된 이름을 가진 쉐이더 파이프라인""""에만 쉐이더가 추가된 것이 있는지 확인한다.
		if (false == JsonInfo.isMember(RES_INFO::SHADER::GRAPHICS::JSON_KEY::_bIsAutoGenerated))
		{
			throw(std::runtime_error("Var _bIsAutoGenerated Missing!!!"));
		}
		//자동생성된 코드인지 여부를 확인
		bool _bIsAutoGenerated = JsonInfo[RES_INFO::SHADER::GRAPHICS::JSON_KEY::_bIsAutoGenerated].asBool();


		//자동생성된 코드일 경우
		if (_bIsAutoGenerated)
		{
			//데이터 확인 후 쉐이더 파이프라인 단계에 차이점이 있을 경우 파이프라인 단계값을 갱신하고 파일로 내보낸다.
			//변경점이 없으면 파일로 내보내지 않는다.
			for (int i = 0; i < (int)eSHADER_TYPE::END; ++i)
			{
				using namespace RES_INFO::SHADER;
				const string strKey = GRAPHICS::JSON_KEY::arr_strKey_PipeLine[i];

				//기존의 값은 비어있는데 새로운 파일명이 존재할 경우 해당 파일명을 옮겨 준다.
				if (JsonInfo[strKey].asString().empty() && false == mapIter.second.FileName[i].empty())
				{
					JsonInfo[strKey] = mapIter.second.FileName[i] + RES_INFO::SHADER::Ext_ShaderCode;
					bModifyDetected = true;
					bAnythingChanged = true;
					vecStrModified.push_back(mapIter.first);
				}
			}
		}

		if (bAnythingChanged)
		{
			ofstream ofs(JsonPath);
			if (ofs.is_open())
			{
				ofs << JsonInfo;
				ofs.close();
			}
		}
	}

	if (bNewShaderDetected || bModifyDetected)
	{
		ofstream ModifiedList(std::filesystem::path(GSShaderDir) / "Modified.txt");
		if (false == ModifiedList.is_open())
		{
			ERROR_MESSAGE("Failed to open Modified.txt");
		}
		ModifiedList << "\n===Recent modified Shader file===\n\n";
		for (size_t i = 0; i < vecStrModified.size(); ++i)
		{
			ModifiedList << vecStrModified[i] + "\n";
		}

		ModifiedList.close();

		if (bNewShaderDetected)
		{
			MessageBoxA(nullptr, "New Shader detected.\nPlease check. Modified.txt", nullptr, MB_OK);
		}
		if (bModifyDetected)
		{
			MessageBoxA(nullptr, "Modification of existing Shader detected.\nPlease check Modified.txt", nullptr, MB_OK);
		}
	}
	

	filesystem::path filePath(PresetPath::ScriptProj);
	filePath /= PresetPath::strKey_Shader;
	std::ofstream fpStrKeyShader(filePath);
	if (true == fpStrKeyShader.is_open())
	{
		//머릿글프리셋 삽입
		string RawLiteral = string(PresetStr::Head);
		fpStrKeyShader << RawLiteral;

		WriteCodeA(fpStrKeyShader, "namespace strKey_RES_SHADER");
		WriteBracketOpenA(fpStrKeyShader);
		WriteCodeA(fpStrKeyShader, "namespace GRAPHICS");
		WriteBracketOpenA(fpStrKeyShader);
		
		for(const auto& GSIter : mapShaderInfo)
		{
			string codeLine = string(PresetStr::ConstexprInlineConstChar);

			//JSON 파일 명
			string strKeyUpper = GSIter.first;
			size_t pos = strKeyUpper.find('.');
			if (string::npos != pos)
				strKeyUpper.erase(pos, string::npos);
			transform(strKeyUpper.begin(), strKeyUpper.end(), strKeyUpper.begin(), ::toupper);
			codeLine += strKeyUpper;
			codeLine += " = \"";

			//CSO 파일 명
			codeLine += GSIter.first + string(RES_INFO::SHADER::Ext_ShaderSetting) + "\";";

			WriteCodeA(fpStrKeyShader, codeLine);
		}
		WriteBracketCloseA(fpStrKeyShader);
		WriteCodeA(fpStrKeyShader);


		WriteCodeA(fpStrKeyShader, "namespace COMPUTE");
		WriteBracketOpenA(fpStrKeyShader);


		filesystem::path CSShaderDir(ContentDir);
		CSShaderDir /= DIRECTORY_NAME::SHADER_COMPUTE;
		try
		{
			dirIter = filesystem::directory_iterator(CSShaderDir);
			for (; false == dirIter._At_end(); ++dirIter)
			{
				if (false == (*dirIter).is_directory())
				{
					//cso 파일을 읽었을 때만 진행.
					filesystem::path FileName = dirIter->path();
					if (0 != FileName.extension().compare(RES_INFO::SHADER::Ext_ShaderCode))
						continue;

					FileName.replace_extension(RES_INFO::SHADER::Ext_ShaderSetting);

					//파일이 존재하면 스킵
					ifstream ifpSetting(FileName);

					if (true == ifpSetting.is_open())
						ifpSetting.close();
					
					//파일이 존재하지 않을 시 파일을 생성
					else
					{
						ofstream outFile(FileName);

						if (outFile.is_open())
						{
							Json::Value ShaderVal;
							InitShaderSettingCompute(ShaderVal, FileName.lexically_relative(CSShaderDir));

							outFile << ShaderVal;

							outFile.close();
						}
					}


					string codeLine = string(PresetStr::ConstexprInlineConstChar);

					string Key = (*dirIter).path().filename().replace_extension().string();

					string Value = Key;


					size_t strPos = Key.find_last_of("_");
					if (string::npos != strPos)
					{
						Key.erase((size_t)0, strPos + (size_t)1);
					}

					transform(Key.begin(), Key.end(), Key.begin(), ::toupper);

					codeLine += Key;
					codeLine += " = \"";
					codeLine += Value + string(RES_INFO::SHADER::Ext_ShaderSetting) + "\";";

					WriteCodeA(fpStrKeyShader, codeLine);
				}
			}
			WriteBracketCloseA(fpStrKeyShader);

			WriteBracketCloseA(fpStrKeyShader);
			WriteCodeA(fpStrKeyShader);

			fpStrKeyShader.close();
		}
		catch (const std::filesystem::filesystem_error& error)
		{
			MessageBoxA(nullptr, error.what(), NULL, MB_OK);
			fpStrKeyShader.close();
			throw(error);
		}

	}





}


void InitShaderSettingGraphics(Json::Value& _jVal, const pair<string, tShaderSetting>& _mapPair)
{
	_jVal.clear();

	CGraphicsShader dummy;

	//파이프라인 정보는 바깥에서 지정할 예정(값을 전달할 방법이 없음)
	//dummy.SetName(_mapPair.second.FileName);
	dummy.SetKey(_mapPair.first);

	//자동 생성 기본값은 true. 수동으로 만든 쉐이더는 이 값을 직접 false로 바꿀 것
	_jVal[RES_INFO::SHADER::GRAPHICS::JSON_KEY::_bIsAutoGenerated] = true;

	//이쪽 코드에서 추가로 설정작업을 해줘야 하기 때문에 포인터를 통해 값을 받아오는 방식을 사용
	dummy.SaveJson(&_jVal);
}


void InitShaderSettingCompute(Json::Value& _jVal, const filesystem::path& _filePath)
{
	filesystem::path CodeFileName = _filePath;
	CodeFileName.replace_extension(RES_INFO::SHADER::Ext_ShaderCode);

	CDummyCompute dummy;

	dummy.SetName(CodeFileName.string());
	dummy.SetKey(_filePath.string());

	dummy.SaveJson(&_jVal);
}
