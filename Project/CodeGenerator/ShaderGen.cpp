#include "pch.h"

#include "CodeGenFunc.h"

#include "MacroFunc.h"



#include <UtilLib_DLL/json/json.h>
#include <Engine/define.h>
#include <d3dcommon.h>

#ifdef _DEBUG
#pragma comment(lib, "Engine/Engine_Debug")
#else
#pragma comment(lib, "Engine/Engine_Release")
#endif

#include <Engine/CComputeShader.h>
#include <Engine/CGraphicsShader.h>

//순수가상함수 풀고 저장기능만 사용하기 위한 더미 클래스
class CDummyCompute
	: public CComputeShader
{
public:
	CDummyCompute() {};
	virtual ~CDummyCompute() {};

	virtual HRESULT InitCS() override { return S_OK; }
	virtual bool BindDataCS() override { return true; };
	virtual void UnBindCS() override {};
};


struct tShaderSetting
{
	string FileName[(int)define_Shader::eSHADER_TYPE::END];
};

void InitShaderSettingGraphics(Json::Value& _jVal, const pair<string, tShaderSetting>& _mapPair);
void InitShaderSettingCompute(Json::Value& _jVal, const filesystem::path& _filePath);

void CreateShaderCode()
{
	filesystem::path strKeyFilePath = filesystem::path(PresetPath::ScriptProj) / PresetPath::strKey_Shader;
	std::ofstream outFile_strKey(strKeyFilePath);
	if (false == outFile_strKey.is_open())
	{
		ERROR_MESSAGE("Failed to Write Shader strKey");
		return;
	}

	CreateGraphicsShaderCode(outFile_strKey);
	CreateComputeShaderCode(outFile_strKey);
}

void CreateGraphicsShaderCode(std::ofstream& _outFile_StrKey)
{
	//first(Key) = json파일의 이름
	//쉐이더의 공통 키값 + 각 쉐이더 파일의 이름을 저장할 공간 생성
	map<string, tShaderSetting> mapShaderInfo;

	filesystem::path GSShaderDir = filesystem::path(PresetPath::Content) / RES_INFO::SHADER::GRAPHICS::DirName;

	//Content/Shader/Graphics 폴더 안의 파일을 순회돌아준다.
	filesystem::directory_iterator dirIter;
	try
	{
		dirIter = filesystem::directory_iterator(GSShaderDir);

		filesystem::directory_iterator dirIterEnd = std::filesystem::end(dirIter);
		for (dirIter; dirIter != dirIterEnd; ++dirIter)
		{
			const filesystem::directory_entry& file = *dirIter;

			if (false == file.is_directory())
			{
				//파일명을 받아온다.
				filesystem::path SFileName = file.path().lexically_relative(GSShaderDir);

				//확장자가 .cso로 끝나는지 확인한다. 확장자가 cso가 아닐 경우 쉐이더가 아니므로 continue;
				if (SFileName.extension() != RES_INFO::SHADER::Ext_ShaderCode)
					continue;

				//확장자 제거
				string SFileNameBase = SFileName.replace_extension("").string();

				//이름을 통해서 어떤 파이프라인인지를 유추한다.
				for (int i = 0; i < (int)define_Shader::eSHADER_TYPE::END; ++i)
				{
					size_t strPos = SFileNameBase.find(RES_INFO::SHADER::GRAPHICS::arrPrefix[i]);
					if (string::npos != strPos)
					{
						//Prefix를 제거
						//이러면 키값으로 사용할 문자열이 남는다.
						SFileNameBase.erase(0, strPos + strlen(RES_INFO::SHADER::GRAPHICS::arrPrefix[i]));

						//자신의 쉐이더 파이프라인에 이름을 삽입
						mapShaderInfo[SFileNameBase].FileName[i] = SFileName.string();

						break;
					}
				}
			}
		}

	}
	catch (const filesystem::filesystem_error& error)
	{
		MessageBoxA(nullptr, "Unable to Iterate Directory.", nullptr, MB_OK);
		assert(false);
		throw(error);
	}
	//생성된 HLSL 파일 순회 끝
	set<string> setStrModified;


	bool bNewShaderDetected = false;
	bool bModifyDetected = false;
	//map을 순회돌아주면서 파일을 열어본다.
	//파일명은 'Key값'이다.
	Json::Value JsonInfo;
	for (const auto& mapIter : mapShaderInfo)
	{
		//JSON 경로 생성
		filesystem::path JsonPath = GSShaderDir;

		bool bAnythingChanged = false;

		JsonPath /= mapIter.first;
		JsonPath.replace_extension(RES_INFO::SHADER::Ext_ShaderSetting);

		ifstream fpJsonIn(JsonPath);
		//파일이 열렸으면 데이터를 읽어온다.
		if (true == fpJsonIn.is_open())
		{
			fpJsonIn >> JsonInfo;

			fpJsonIn.close();
		}
		//파일이 없을 경우 JsonValue를 포맷에 맞게 초기화시킨다.
		//초기화될 때 이름은 자동으로 들어감.
		else
		{
			InitShaderSettingGraphics(JsonInfo, mapIter);
			bAnythingChanged = true;
			bNewShaderDetected = true;

			setStrModified.insert(mapIter.first);
		}


		//"""""정규화된 이름을 가진 쉐이더 파이프라인""""에만 쉐이더가 추가된 것이 있는지 확인한다.
		if (false == JsonInfo.isMember(RES_INFO::SHADER::GRAPHICS::JSON_KEY::_bIsAutoGenerated))
		{
			throw(std::runtime_error("Var _bIsAutoGenerated Missing!!!"));
		}
		//자동생성된 코드인지 여부를 확인
		bool _bIsAutoGenerated = JsonInfo[RES_INFO::SHADER::GRAPHICS::JSON_KEY::_bIsAutoGenerated].asBool();


		//자동생성된 코드일 경우
		if (_bIsAutoGenerated)
		{
			//데이터 확인 후 쉐이더 파이프라인 단계에 차이점이 있을 경우 파이프라인 단계값을 갱신하고 파일로 내보낸다.
			//변경점이 없으면 파일로 내보내지 않는다.
			for (int i = 0; i < (int)define_Shader::eSHADER_TYPE::END; ++i)
			{
				using namespace RES_INFO::SHADER;
				const string strKey = GRAPHICS::JSON_KEY::arr_strKey_PipeLine[i];

				//기존의 값은 비어있는데 새로운 파일명이 존재할 경우 해당 파일명을 옮겨 준다.
				if (JsonInfo[strKey].asString().empty() && false == mapIter.second.FileName[i].empty())
				{
					JsonInfo[strKey] = mapIter.second.FileName[i] + RES_INFO::SHADER::Ext_ShaderCode;
					bModifyDetected = true;
					bAnythingChanged = true;
					setStrModified.insert(mapIter.first);
				}
			}
		}

		if (bAnythingChanged)
		{
			ofstream ofs(JsonPath);
			if (ofs.is_open())
			{
				ofs << JsonInfo;
				ofs.close();
			}
		}
	}


	if (bNewShaderDetected || bModifyDetected)
	{
		ofstream ModifiedList(std::filesystem::path(GSShaderDir) / "Modified.txt");
		if (false == ModifiedList.is_open())
		{
			ERROR_MESSAGE("Failed to open Modified.txt");
		}
		ModifiedList << "\n===Recent modified Shader file===\n\n";

		for (const auto& iter : setStrModified)
		{
			ModifiedList << iter + "\n";
		}
		ModifiedList.close();

		if (bNewShaderDetected)
		{
			MessageBoxA(nullptr, "New Shader detected.\nPlease check. Modified.txt", nullptr, MB_OK);
		}
		if (bModifyDetected)
		{
			MessageBoxA(nullptr, "Modification of existing Shader detected.\nPlease check Modified.txt", nullptr, MB_OK);
		}
	}


	//쉐이더 문자열 키 등록
	//그래픽 쉐이더 Key 작성
	//머릿글프리셋 삽입
	string RawLiteral = string(PresetStr::Head);
	_outFile_StrKey << RawLiteral;

	WriteCodeA(_outFile_StrKey, "namespace strKey_SHADER");
	WriteBracketOpenA(_outFile_StrKey);
	WriteCodeA(_outFile_StrKey, "namespace GRAPHICS");
	WriteBracketOpenA(_outFile_StrKey);

	for (const auto& GSIter : mapShaderInfo)
	{
		string codeLine = string(PresetStr::ConstexprInlineConstChar);

		//JSON 파일 명
		string strKeyUpper = GSIter.first;
		size_t pos = strKeyUpper.find('.');
		if (string::npos != pos)
			strKeyUpper.erase(pos, string::npos);
		transform(strKeyUpper.begin(), strKeyUpper.end(), strKeyUpper.begin(), ::toupper);
		codeLine += strKeyUpper;
		codeLine += " = \"";

		//CSO 파일 명
		codeLine += GSIter.first + string(RES_INFO::SHADER::Ext_ShaderSetting) + "\";";

		WriteCodeA(_outFile_StrKey, codeLine);
	}
	WriteBracketCloseA(_outFile_StrKey);
}

void CreateComputeShaderCode(std::ofstream& _outFile_StrKey)
{
	WriteCodeA(_outFile_StrKey);

	WriteCodeA(_outFile_StrKey, "namespace COMPUTE");
	WriteBracketOpenA(_outFile_StrKey);

	filesystem::path CSShaderDir(PresetPath::Content);
	CSShaderDir /= DIRECTORY_NAME::SHADER_COMPUTE;
	try
	{
		//발견한 파일 목록
		vector<string> vecFoundFile;

		filesystem::directory_iterator dirIter = filesystem::directory_iterator(CSShaderDir);
		for (; false == dirIter._At_end(); ++dirIter)
		{
			if (false == (*dirIter).is_directory())
			{
				//cso 파일을 읽었을 때만 진행.
				filesystem::path FileName = dirIter->path();
				if (0 != FileName.extension().compare(RES_INFO::SHADER::Ext_ShaderCode))
					continue;
				FileName.replace_extension(RES_INFO::SHADER::Ext_ShaderSetting);

				//HLSL파일(소스코드) 존재 여부 및 스레드 수 체크
				int numThread[3] = { -1, -1, -1 };
				{
					std::filesystem::path hlslFile = PresetPath::EngineProj;
					hlslFile /= FileName.filename().replace_extension("hlsl");

					std::ifstream fHLSL(hlslFile);
					if (fHLSL.is_open())
					{	
						string strLine;
						while (std::getline(fHLSL, strLine))
						{
							std::regex regexKey(Regex_Keyword::Numthread);	//정규식
							std::smatch numMatch;	//조건에 일치하는 값들을 추출해놓은 위치
							//원문, 일치하는 값 저장소, 정규식 위치

							//일치하고, 일치하는 부분의 사이즈가 4개일 경우
							if (std::regex_search(strLine, numMatch, regexKey) && (size_t)4 == numMatch.size())
							{
								//0번 인덱스에는 일치하는 부분의 시작과 끝 부분 전체가 들어있다.
								numThread[0] = std::stoi(numMatch[1]);
								numThread[1] = std::stoi(numMatch[2]);
								numThread[2] = std::stoi(numMatch[3]);
							}
						}
					}
				}


				{
					//파일 오픈
					ifstream fSetting(FileName);
					Json::Value CShaderJVal;

					//코드 파일이 없는데 설정 파일이 있을 경우 json 파일을 제거
					if (-1 == numThread[0] && fSetting.is_open())
					{
						fSetting.close();
						std::filesystem::remove(FileName);
						continue;
					}

					//파일이 없을 경우 json 값을 초기화
					else if (false == fSetting.is_open())
					{
						//경로에서 ShaderDir까지를 빼준다(lexically_relative)
						InitShaderSettingCompute(CShaderJVal, FileName.lexically_relative(CSShaderDir));

						//새로 발견한 컴퓨트쉐이더 파일 이름을 넣어준다.
						vecFoundFile.push_back(FileName.filename().string());
					}

					fSetting.close();


					//스레드 갯수를 입력
					for (int i = 0; i < 3; ++i)
					{
						CShaderJVal[RES_INFO::SHADER::COMPUTE::JSON_KEY::uarrNumThreadXYZ][i] = numThread[i];
					}

					//컴퓨트쉐이더 파일 저장
					{
						ofstream ofSetting(FileName);

						if (false == ofSetting.is_open())
							throw(std::runtime_error("Failed to Save Compute Shader Json File!!"));

						ofSetting << CShaderJVal;
						ofSetting.close();
					}
				}

				string codeLine = string(PresetStr::ConstexprInlineConstChar);

				string Key = (*dirIter).path().filename().replace_extension().string();

				string Value = Key;

				string prefix = RES_INFO::SHADER::COMPUTE::Prefix;
				size_t strPos = Key.find(prefix);
				if (string::npos != strPos)
				{
					Key.erase((size_t)0, prefix.length() + 1);
				}

				transform(Key.begin(), Key.end(), Key.begin(), ::toupper);

				codeLine += Key;
				codeLine += " = \"";
				codeLine += Value + string(RES_INFO::SHADER::Ext_ShaderSetting) + "\";";

				WriteCodeA(_outFile_StrKey, codeLine);
			}
		}
		WriteBracketCloseA(_outFile_StrKey);

		WriteBracketCloseA(_outFile_StrKey);
		WriteCodeA(_outFile_StrKey);

		_outFile_StrKey.close();

		if (false == vecFoundFile.empty())
		{
			string msg = "New Compute shader Found!!\n===List===\n";
			for (size_t i = 0; i < vecFoundFile.size(); ++i)
			{
				msg += vecFoundFile[i] + '\n';
			}

			MessageBoxA(nullptr, msg.c_str(), nullptr, MB_OK);
		}
	}
	catch (const std::filesystem::filesystem_error& error)
	{
		MessageBoxA(nullptr, error.what(), NULL, MB_OK);
		_outFile_StrKey.close();
		throw(error);
	}

}


void InitShaderSettingGraphics(Json::Value& _jVal, const pair<string, tShaderSetting>& _mapPair)
{
	_jVal.clear();

	CGraphicsShader dummy;

	//파이프라인 정보는 바깥에서 지정할 예정(값을 전달할 방법이 없음)
	//dummy.SetName(_mapPair.second.FileName);
	dummy.SetKey(_mapPair.first);

	//자동 생성 기본값은 true. 수동으로 만든 쉐이더는 이 값을 직접 false로 바꿀 것
	_jVal[RES_INFO::SHADER::GRAPHICS::JSON_KEY::_bIsAutoGenerated] = true;

	//이쪽 코드에서 추가로 설정작업을 해줘야 하기 때문에 포인터를 통해 값을 받아오는 방식을 사용
	dummy.SaveJson(&_jVal);
}


void InitShaderSettingCompute(Json::Value& _jVal, const filesystem::path& _filePath)
{
	filesystem::path CodeFileName = _filePath;
	CodeFileName.replace_extension(RES_INFO::SHADER::Ext_ShaderCode);

	CDummyCompute dummy;

	dummy.SetName(CodeFileName.string());
	dummy.SetKey(_filePath.string());

	dummy.SaveJson(&_jVal);
}


