#include "pch.h"

#include "CodeGenFunc.h"
#include "MacroFunc.h"

constexpr std::string_view ScriptStandardPrefix = "CScript_";
constexpr std::string_view ScriptStandardSuffix = ".h";

void CreateScriptCode()
{
	string ScriptPath = "./Project/Script/";

	//Key = strKey의 변수명, Value = 파일명
	unordered_map<string, string> mapScripts;

	std::filesystem::directory_iterator iter(ScriptPath);
	while (std::filesystem::end(iter) != iter)
	{
		const std::filesystem::directory_entry& entry = *iter;

		const string& ScriptVal = entry.path().filename().string();

		//"CScript_" 와 .h가 붙어있는 파일들만 추가
		if (string::npos != ScriptVal.find(string(ScriptStandardPrefix)) && string::npos != ScriptVal.find(string(ScriptStandardSuffix)))
		{
			string ScriptKey = ScriptVal;

			//앞부분 제거
			ScriptKey.erase(0, ScriptStandardPrefix.size());

			//뒷부분 제거
			size_t pos = ScriptKey.find(string(ScriptStandardSuffix));
			if (string::npos != pos)
				ScriptKey.erase(pos, ScriptStandardSuffix.size());

			//대문자로 변경
			transform(ScriptKey.begin(), ScriptKey.end(), ScriptKey.begin(), ::toupper);


			mapScripts.insert(make_pair(ScriptKey, ScriptVal));
		}

		++iter;
	}


	//strKey 작성
	string strKeyPath = ScriptPath + "strKeyScript.h";
	std::ofstream strKey(strKeyPath);
	if (false == strKey.is_open())
		return;

	WriteCodeA(strKey, "#pragma once");
	WriteCodeA(strKey);

	WriteCodeA(strKey, "//This Code is Automatically generated by CodeGenerator.exe");
	WriteCodeA(strKey);

	WriteCodeA(strKey, "namespace SCRIPTS");
	WriteCodeA(strKey, "{");

	
	const string& BaseCode = "constexpr const char* ";
	for (const auto& iter : mapScripts)
	{
		string FinalCodeLine = BaseCode + iter.first + " = ";
		FinalCodeLine += "\"";
		FinalCodeLine += iter.second + '"';
		FinalCodeLine += ";";
		WriteCodeA(strKey, FinalCodeLine);
	}

	WriteCodeA(strKey, "}");

	strKey.close();


	//CScriptMgr 작성
	string ScriptMgrPath = ScriptPath + "CScriptMgr.cpp";
	std::ofstream ScriptMgr(ScriptMgrPath);
	if (false == ScriptMgr.is_open())
		return;

	//기본 include
	string RawLiteral = R"(
#pragma once

#include "pch.h"
#include "CScriptMgr.h"

)";
	ScriptMgr << RawLiteral;


	//생성된 스크립트 순회돌며 삽입
	WriteCodeA(ScriptMgr, "//Created Scripts");
	for (const auto& iter : mapScripts)
	{
		IncludeFileA(ScriptMgr, iter.second);
	}
	WriteCodeA(ScriptMgr);


	//생성자 및 소멸자
	RawLiteral = R"(


CScriptMgr::CScriptMgr() {}
CScriptMgr::~CScriptMgr()
{
	for(const auto& iter : m_umapScript)
	{
		DESTRUCTOR_DELETE(iter.second);
	}
}

)";
	ScriptMgr << RawLiteral;


	//init()
	WriteCodeA(ScriptMgr, "void CScriptMgr::init()");
	WriteCodeA(ScriptMgr, "{");
	
	for (const auto& iter : mapScripts)
	{
		string className = "m_umapScript[";
		className += "SCRIPTS::" + iter.first + "] = new ";
		
		size_t pos = iter.second.find(string(ScriptStandardSuffix));
		className.append(iter.second.substr(0, pos));
		className += ';';

		WriteCodeA(ScriptMgr, className);
	}

	WriteCodeA(ScriptMgr, "}");


	RawLiteral = R"(

CScript* CScriptMgr::GetNewScript(const string& _strKey)
{
	const auto& iter = m_umapScript.find(_strKey);

	if (iter == m_umapScript.end())
		return nullptr;

	return iter->second->Clone();
}
)";

	ScriptMgr << RawLiteral;


	ScriptMgr.close();
}
